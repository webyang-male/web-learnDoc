### 面向过程 与  面向对象       

> JavaScript是一种基于对象的语言

面向过程是一件事“该怎么做“，面向对象是一件事“该让谁来做”，然后那个“谁”就是对象，他要怎么做是他自己的事，反正最后一群对象合力能把事做好就行了。 				------ 知乎

#### 类和对象

类(class)是对象(object)的模板，定义了同一组对象共有的属性和方法

### 类与继承

#### ES5中的类与继承

##### 类

> 静态方法里的this指向构造函数
>
> 构造函数this指向实例化对象

````js
// 类
function People(name, age) {
    // console.log(this)
    this.name = name
    this.age = age
}
// 实例方法
People.prototype.showName = function () {
    console.log('我的名字是' + this.name)
}
// {name: 'LX', age: 18}
// 我的名字是LX
// {name: 'zhangsan', age: 18}
// 我的名字是zhangsan
let p1 = new People('LX', 18)
console.log(p1)
p1.showName()

let p2 = new People('zhangsan', 18)
console.log(p2)
p2.showName()
````

> 一般情况下，方法不会写在构造函数下(每次实例化都会有一个方法) 一般放在原型上 

```js
// 类
function People(name, age) {
    // console.log(this)
    // 实例属性
    this.name = name
    this.age = age
    People.count++
}
// 静态属性
People.count = 0
// 静态方法
People.getCount = function(){
  /* ƒ People(name, age) {
    console.log(this); // 实例属性
    this.name = name;
    this.age = age;
    People.count++;
  } */
    console.log(this)//指向构造函数
    console.log(this.age) // undefined
    console.log('当前共有' + People.count + '个人')
}

// 实例方法
People.prototype.showName = function () {
    console.log('我的名字是' + this.name)
}

//p1,p2实例化对象
let p1 = new People('lx', 18)
console.log(p1)
p1.showName()

let p2 = new People('zhangsan', 20)
console.log(p2)
p2.showName()

console.log(People.count)
People.getCount()//静态方法调用

// let str = new String('imooc')
// console.log(str)

// let arr = new Array(1, 2, 3)
// console.log(arr)

// let obj = new Object()
// obj.name = 'zain'
// console.log(obj)

// 静态方法
// console.log(Math.max(4, 5))
// console.log(Math.random())
```

##### 继承

> 构造函数继承只能继承父类的属性，原型的继承可以继承方法

`````js
// 父类
function Animal(name) {
    this.name = name
}
Animal.prototype.showName = function () {
    console.log('名字是:' + this.name)
}

// 子类
function Dog(name, color) {
    Animal.call(this, name) // 构造函数继承属性
    this.color = color
}
//原型继承方法
Dog.prototype = new Animal()
//prototype的constructor属性应该是指向它的构造函数的。
//上面这一句让Dog.prototype.constructor指向了Animal，所以需要改回Dog
Dog.prototype.constuctor = Dog

let d1 = new Dog('wangcai', 'white')
console.log(d1)
d1.showName()
//Dog {name: 'wangcai', color: 'white'}
//名字是:wangcai
`````

#### ES6中的类与继承

````js
class People {
    constructor(name, age) {//构造函数constructor
        this.name = name
        this.age = age
        this._sex = -1
    }
    // static count = 0
    get sex() { // 属性
        if (this._sex === 1) {
            return 'male'
        } else if (this._sex === 0) {
            return 'female'
        } else {
            return 'error'
        }
    }
    set sex(val) { // 1:male 0:female
        if (val === 0 || val === 1) {
            this._sex = val
        }
    }
    showName() {
        console.log(this.name)
    }
    // 静态方法
    static getCount() {
        return 5
    }
}
// 静态属性
People.count = 9
console.log(typeof People) // function
console.log(People.count)

let p1 = new People('zain', 18)
console.log(p1)
p1.sex = 5
console.log(p1.sex)
console.log(People.getCount())

//extends实现类之间的继承
class Coder extends People {
    constructor(name, age, company) {
        super(name, age)//super关键字继承父类属性和方法
        this.company = company
    }
    showCompany() {
        console.log(this.company)
    }
}

let c1 = new Coder('zhangsan', 25, 'imooc')
console.log(c1)
c1.showName()
c1.showCompany()
c1.sex = 1
console.log(c1.sex)
console.log(Coder.getCount())
````

##### ✒【拓展理解】

​		<font style="color:deepskyblue;">class实现继承的注意事项</font>

1、class 声明不会提升。Foo 进入暂时性死区，类似于 let、const 声明变量

````js
const bar = new Bar(); // it's ok
function Bar() {
  this.bar = 42;
}

const foo = new Foo(); // ReferenceError: Foo is not defined
class Foo {
  constructor() {
    this.foo = 42;
  }
}
````

2、class 声明内部会启用严格模式

````js
// 引用一个未声明的变量
function Bar() {
  baz = 42; // it's ok
}
const bar = new Bar();

class Foo {
  constructor() {
    fol = 42; // ReferenceError: fol is not defined
  }
}
const foo = new Foo();
````

3、class 的所有方法（包括静态方法和实例方法）都是不可枚举的

````js
// 引用一个未声明的变量
function Bar() {
  this.bar = 42;
}
Bar.answer = function() {
  return 42;
};
Bar.prototype.print = function() {
  console.log(this.bar);
};
const barKeys = Object.keys(Bar); // ['answer']
const barProtoKeys = Object.keys(Bar.prototype); // ['print']

class Foo {
  constructor() {
    this.foo = 42;
  }
  static answer() {
    return 42;
  }
  print() {
    console.log(this.foo);
  }
}
const fooKeys = Object.keys(Foo); // []
const fooProtoKeys = Object.keys(Foo.prototype); // []
````

4、class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用

````js
function Bar() {
  this.bar = 42;
}
Bar.prototype.print = function() {
  console.log(this.bar);
};

const bar = new Bar();
const barPrint = new bar.print(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
  print() {
    console.log(this.foo);
  }
}
const foo = new Foo();
const fooPrint = new foo.print(); // TypeError: foo.print is not a constructor
````

5、必须使用 new 调用 class

```js
function Bar() {
  this.bar = 42;
}
const bar = Bar(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
}
const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new'
```

6、class 内部无法重写类名

```js
function Bar() {
  Bar = 'Baz'; // it's ok
  this.bar = 42;
}
const bar = new Bar();
// Bar: 'Baz'
// bar: Bar {bar: 42}  

class Foo {
  constructor() {
    this.foo = 42;
    Foo = 'Fol'; // TypeError: Assignment to constant variable
  }
}
const foo = new Foo();
Foo = 'Fol'; // it's ok
```

### 原始数据类型Symbol

> ES6 引入了一种新的原始数据类型 `Symbol` ，表示独一无二的值。

#### 声明方式

1.简单声明(难以理解其代表意义)

````js
let s1 = Symbol()
let s2 = Symbol()
console.log(s1)
console.log(s2)
console.log(s1 === s2) // false
````

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></div>

2.字符串声明

> Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

````js
let s1 = Symbol('foo')
let s2 = Symbol('bar')
console.log(s1)
console.log(s2)
console.log(s1 === s2)// false
````

3.对象方法

`````js
const obj = {
    name: 'imooc',
    toString() {
        return this.name
    }
}
let s = Symbol(obj)
console.log(s)//Symbol(imooc)
`````

#### 1个API

````js
let s = Symbol('foo')
console.log(s.description)//foo
````

#### Symbol.for()

`Symbol.for()` 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到`全局`。

```js
let s1 = Symbol.for('foo')
let s2 = Symbol.for('foo')
console.log(s1 === s2) // true
```

````js
function foo() {
    return Symbol.for('foo')
}
const x = foo()
const y = Symbol.for('foo')
console.log(x === y) // true
````

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。</p></div>

#### Symbol.keyFor()

> Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。

```js
const s1 = Symbol('foo')
console.log(Symbol.keyFor(s1)) // undefined

const s2 = Symbol.for('foo')
console.log(Symbol.keyFor(s2)) // foo
```

#### 使用场景

##### 作为属性名

由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

比如在一个班级中，可能会有同学名字相同的情况，这时候使用对象来描述学生信息的时候，如果直接使用学生姓名作为key会有有问题。

```js
const grade = {
    张三: {
        address: 'xxx',
        tel: '111'
    },
    李四: {
        address: 'yyy',
        tel: '222'
    },
    李四: {
        address: 'zzz',
        tel: '333'
    },
}
console.log(grade)
// 只会保留最后一个李四
```

如果使用Symbol，同名的学生信息就不会被覆盖：

```js
const stu1 = Symbol('李四')
const stu2 = Symbol('李四')
const grade = {
    [stu1]: {
        address: 'yyy',
        tel: '222'
    },
    [stu2]: {
        address: 'zzz',
        tel: '333'
    },
}
console.log(grade)
console.log(grade[stu1])
console.log(grade[stu2])
```

##### 属性遍历

````js
const sym = Symbol('imooc')
class User {
    constructor(name) {
        this.name = name
        this[sym] = 'imooc.com'
    }
    getName() {
        return this.name + this[sym]
    }
}
const user = new User('xiecheng')
console.log(user.getName())

for (let key in user) {
    console.log(key)
}

for (let key of Object.keys(user)) {
    console.log(key)
}

for (let key of Object.getOwnPropertySymbols(user)) {
    console.log(key)
}
//正常遍历出
for (let key of Reflect.ownKeys(user)) {
    console.log(key)
}
````

##### 消除魔术字符串

魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。

```js
function getArea(shape) {
    let area = 0
    switch (shape) {
        case 'Triangle':
            area = 1
            break
        case 'Circle':
            area = 2
            break
    }
    return area
}
console.log(getArea('Triangle'))
```

上面代码中，字符串Triangle和Circle就是魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。

使用Symbol就可以很好的解决这个问题：

```js
const shapeType = {
    triangle: Symbol(),
    circle: Symbol()
}

function getArea(shape) {
    let area = 0
    switch (shape) {
        case shapeType.triangle:
            area = 1
            break
        case shapeType.circle:
            area = 2
            break
    }
    return area
}
console.log(getArea(shapeType.triangle))
```

###  Set

在 JavaScript 里通常使用 Array 或 Object 来存储数据。但是在频繁操作数据的过程中查找或者统计并需要手动来实现，并不能简单的直接使用。 比如如何保证 Array 是去重的，如何统计 Object 的数据总数等，必须自己去手动实现类似的需求，不是很方便。 在 ES6 中为了解决上述痛点，新增了数据结构 Set 和 Map，它们分别对应传统数据结构的“集合”和“字典”。

> ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

#### 基本语法

##### 生成 Set 实例

```js
  let s = new Set()
```

可以定义一个空的 Set 实例，也可以在实例化的同时传入默认的数据。

```js
  let s = new Set([1, 2, 3, 4])
```

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>初始化的参数必须是可遍历的，可以是数组或者自定义遍历的数据结构。</p></div>

##### 添加数据

```js
  s.add('hello')
  s.add('LX')
```

或者

```js
  s.add('hello').add('许丽')
```

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>Set 数据结构不允许数据重复，所以添加重复的数据是无效的</p></div>

##### 删除数据

删除数据分两种，一种是删除指定的数据，一种是删除全部数据。

```js
  // 删除指定数据
  s.delete('hello') // true
  // 删除全部数据
  s.clear()
```

##### 统计数据

Set 可以快速进行统计数据，如数据是否存在、数据的总数。

```js
  // 判断是否包含数据项，返回 true 或 false
  s.has('hello') // true
  // 计算数据项总数
  s.size // 2
```

#### ⚙️应用场景

##### 数组去重

```js
let arr = [1, 2, 3, 4, 2, 3]
let s = new Set(arr)
console.log(s)
```

##### 合并去重

```js
let arr1 = [1, 2, 3, 4]
let arr2 = [2, 3, 4, 5, 6]
let s = new Set([...arr1, ...arr2])
console.log(s)
//转为数组
console.log([...s])
console.log(Array.from(s))
```

##### 交集

```js
let s1 = new Set(arr1)
let s2 = new Set(arr2)
let result = new Set(arr1.filter(item => s2.has(item)))
console.log(Array.from(result))
```

##### 差集

```js
let arr3 = new Set(arr1.filter(item => !s2.has(item)))
let arr4 = new Set(arr2.filter(item => !s1.has(item)))
console.log(arr3)
console.log(arr4)
console.log([...arr3, ...arr4])
```

#### 遍历

- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回键值对的遍历器
- forEach()：使用回调函数遍历每个成员
- for...of：可以直接遍历每个成员

```js
let s  =new Set(["hi","lx"]);
console.log(1,s.keys()) // Set { 'lx', 'hi' }
console.log(2,s.values()) // Set { 'hi', 'lx' }
console.log(3,s.entries()) // Set { 'hi', 'lx' }
s.forEach(item => {
    console.log(4,item) 
})

for (let item of s) {
    console.log(5,item)
}

for (let item of s.keys()) {
    console.log(6,item)
}

for (let item of s.values()) {
    console.log(7,item)
}

for (let item of s.entries()) {
    console.log(item[0], item[1])
}
```

![](https://cdn.jsdelivr.net/gh/webyang-male/yangimgs/set-1.png)

####  WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

WeakSet 的成员只能是对象，而不能是其他类型的值。

```js
const ws = new WeakSet()
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set
let ws = new WeakSet()
const obj1 = {
    name: 'imooc'
}
const obj2 = {
    age: 5
}
ws.add(obj1)
ws.add(obj2)
ws.delete(obj1)
console.log(ws)
console.log(ws.has(obj2))
```

<font style="color:darkorange;">WeakSet 没有size属性，没有办法遍历它的成员。</font>

WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

### Map

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

#### 实例化

```js
  let map = new Map([iterable])
```

Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ], [ 2, 'two' ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。

#### 添加数据

```js
  let keyObj = {}
  let keyFunc = function() {}
  let keyString = 'a string'

  // 添加键
  map.set(keyString, "和键'a string'关联的值")
  map.set(keyObj, '和键keyObj关联的值')
  map.set(keyFunc, '和键keyFunc关联的值')
```

````js
let m = new Map()
let obj = {
    name: 'imooc'
}
m.set(obj, 'es')
console.log(m.get(obj))//es
m.delete(obj)
console.log(m)// Map(0)
````

#### 删除数据

```js
  // 删除指定的数据
  map.delete(keyObj)
  // 删除所有数据
  map.clear()
```

#### 统计数据

```js
  // 统计所有 key-value 的总数
  console.log(map.size) //2
  // 判断是否有 key-value
  console.log(map.has(keyObj)) // true
```

````js
let map = new Map([
    ['name', 'tb'],
    ['age', 18]
])
console.log(map.size)//2
console.log(map.has('name'))//true
console.log(map.get('age'))//18
map.set('name', 'zhangsan')
map.delete('name')
console.log(map)//Map(1) {'age' => 5}
````

#### 查询数据

get() 方法返回某个 Map 对象中的一个指定元素

```js
  console.log(map.get(keyObj)) // 和键keyObj关联的值
```

#### 遍历方式

- keys() 返回一个新的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的 key 值
- values() 方法返回一个新的 Iterator 对象。它包含按顺序插入Map对象中每个元素的 value 值
- entries() 方法返回一个新的包含 [key, value] 对的 Iterator ? 对象，返回的迭代器的迭代顺序与 Map 对象的插入顺序相同
- forEach() 方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数
- for...of 可以直接遍历每个成员

```js
   map.forEach((value, key) => console.log(value, key))

   for (let [key, value] of map) {
       console.log(key, value)
   }

   for (let key of map.keys()) {
       console.log(key)
   }

   for (let value of map.values()) {
       console.log(value)
   }

   for (let [key, value] of map.entries()) {
       console.log(key, value)
   }
```

<font style="color:gold;">其实 Object 也是按键值对存储和读取的，那么他俩之间除了我们之前说的区别以外还有其他的吗？</font>

- **键的类型**

  一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。

- **键的顺序**

  Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。

- **键值对的统计**

  你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。

- **键值对的遍历**

  Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。

- **性能**

  Map 在涉及频繁增删键值对的场景下会有些性能优势。
  

  <font style="color:deepskyblue;">map应用场景：判断对象有没有某个key有has方法、size方法直接获取对虾干属性的个数、属性名的种类更多样、性能比对象更好</font>

#### WeekMap

WeakMap结构与Map结构类似，也是用于生成键值对的集合。

```js
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap()
const key = {
    foo: 1
}
wm1.set(key, 2)
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3]
const k2 = [4, 5, 6]
const wm2 = new WeakMap([
    [k1, 'foo'],
    [k2, 'bar']
])
wm2.get(k2) // "bar"
```

WeakMap与Map的区别有两点。

- WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。

```js
const map = new WeakMap()
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
```

- WeakMap的键名所指向的对象，不计入垃圾回收机制。

  

  ````js
  let wm = new WeakMap()
  let elem = document.getElementsByTagName('h1')
  wm.set(elem, 'info')
  console.log(wm.get(elem))
  ````

<em>这里elem被引用了一次，垃圾回收机制记录elem这个节点引用次数一次，weakmap是弱引用，wm.set(elem,'info'),这里又引用一次，但不会进入垃圾回收机制，引用次数不会增加，所以elem这个元素总的引用次数是一次，如果有一天，这个元素被删掉，垃圾回收机制引用次数变为0，weakmap是弱引用，对被删除元素的引用并不会影响垃圾回收机制的记录次数，此时是0，所以这里的elem对象被回收，对应weakmap里面的键值对也会消失，所以weakmap这种数据结构是有助于防止内存泄漏的，这就是weakmap的应用场景</em>

📝WeakMap：键名只支持引用类型（数组、对象、function），对对象的引用是弱引用

​	不支持clear、size方法、不能遍历、也是弱引用类型

### String扩展

#### Unicode表示法

ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。

```js
"\u0061"
// "a"
```

但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。

```js
"\uD842\uDFB7"
// "𠮷"

"\u20BB7"
// " 7"
```

上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。

ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。

```js
"\u{20BB7}"
// "𠮷"
```

有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。

```js
'\z' === 'z' // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

#### 遍历器接口

ES6 为字符串添加了遍历器接口，详见Iterator，使得字符串可以被for...of循环遍历。

```js
for (let item of 'CHINA') {
    console.log(item)
}
```

#### <font style="color:darkorange;">模板字符串</font>

在模板字符串语句中可以任意插入变量或者表达式，只要用[``${}``]包起来就好。

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>这里的符号是反引号，也就是数字键 1 左边的键，不是单引号或者双引号</p></div>

##### 换行

这样就可以轻松解决字符串包含变量或者表达式的问题了，对于多行的字符串，之前是这样处理

```js
console.log('string text line 1\n' +
    'string text line 2')
// "string text line 1
// string text line 2"
```

现在可以这样做了

```js
console.log(`string text line 1
string text line 2`)
// "string text line 1
// string text line 2"
```

##### Tag Literals	

前面的字符串字面量解决了字符串拼接的问题，对于包含复杂逻辑的字符串并不是简单的表达式能搞定的。所以需要另一种解决方案：Tag Literals

```js
var retailPrice = 20
var wholesalePrice = 16
var type = 'retail'

var showTxt = ''

if (type === 'retail') {
    showTxt += '您此次的购买单价是：' + retailPrice
} else {
    showTxt += '您此次的批发价是：' + wholesalePrice
}
```

现在可以定义一个 Tag 函数，然后用这个 Tag 函数来充当一个模板引擎：

```js
function Price(strings, type) {
    let s1 = strings[0]
    const retailPrice = 20
    const wholesalePrice = 16
    let txt = ''
    if (type === 'retail') {
        txt = `购买单价是：${retailPrice}` 
    } else {
        txt = `批发价是：${wholesalePrice}` 
    }
    return `${s1}${txt}` 
}

let showTxt = Price `您此次的${'retail'}` 

console.log(showTxt) //您此次的购买单价是：20
```

> TIP
>
> strings 参数指的是 Tag 函数后面被变量分割开的字符串集合，type 参数是对应第一个变量，Tag 函数可以有多个 type 类似的参数

#### 扩展方法

##### String.prototype.fromCodePoint()

用于从 Unicode 码点返回对应字符，并且可以识别大于0xFFFF的字符。

```js
// ES5
console.log(String.fromCharCode(0x20BB7))	//打印未知符号,因为es5最大支持码点不超过FFFF

// ES6
console.log(String.fromCodePoint(0x20BB7))
```

##### String.prototype.includes()

ES5中可以使用indexOf方法来判断一个字符串是否包含在另一个字符串中，indexOf返回出现的下标位置，如果不存在则返回-1。

```js
const str = 'imooc'

console.log(str.indexOf('mo'))
```

ES6提供了includes方法来判断一个字符串是否包含在另一个字符串中，返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.includes('mo'))
```

##### String.prototype.startsWith()

判断参数字符串是否在原字符串的头部, 返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.startsWith('im'))
```

##### String.prototype.endsWith()

判断参数字符串是否在原字符串的尾部, 返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.endsWith('mooc'))
```

##### String.prototype.repeat()

repeat方法返回一个新字符串，表示将原字符串重复n次。

```js
const str = 'imooc'

const newStr = str.repeat(10)

console.log(newStr)
```

###  RegExp

#### y修饰符

ES6为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。

y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

```js
const s = 'aaa_aa_a'
const r1 = /a+/g
const r2 = /a+/y

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是`_aa_a`。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从`头部`开始，所以返回null。

如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。

```js
const s = 'aaa_aa_a'
const r = /a+_/y

r.exec(s) // ["aaa_"]
r.exec(s) // ["aa_"]
```

```js
const s = 'aaa_aa_a'
const r = /a+_/y

r.exec(s) // ["aaa_"]
r.exec(s) // ["aa_"]
```

上面代码每次匹配，都是从剩余字符串的头部开始。

使用lastIndex属性，可以更好地说明y修饰符。

```js
const regexp = /a/g

// 指定从2号位置（y）开始匹配
regexp.lastIndex = 2

// 匹配成功
const match = regexp.exec('xaya')

// 在3号位置匹配成功
console.log(match.index) // 3

// 下一次匹配从4号位开始
console.log(regexp.lastIndex) // 4

// 4号位开始匹配失败
regexp.exec('xaxa') // null
```

上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。

y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。

```js
const regexp = /a/y

// 指定从2号位置开始匹配
regexp.lastIndex = 2

// 不是粘连，匹配失败
regexp.exec('xaya') // null

// 指定从3号位置开始匹配
regexp.lastIndex = 3

// 3号位置是粘连，匹配成功
const match = regexp.exec('xaxa')
console.log(match.index) // 3
console.log(regexp.lastIndex) // 4
```

进一步说，y修饰符号隐含了头部匹配的标志^。

```js
const reg = /b/y
reg.exec('aba')
// null
console.log(reg.lastIndex)
```

> TIP
>
> sticky 模式在正则匹配过程中只会影响两件事：
>
> - 匹配必须从 re.lastIndex 开始（相当于正则表达中的 ^）
> - 如果匹配到会修改 re.lastIndex（相当于 g 模式）

#### u修饰符

ES6为正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于 `\uFFFF` 的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。

````js
// u修饰符 unicode
// \u0000~\uffff
const str = '\uD842\uDFB7' // 表示一个字符
console.log(/^\uD842/.test(str)) // es5 true
console.log(/^\uD842/u.test(str)) // es6 false
````

上面代码中， `\uD83D\uDC2A` 是一个四个字节的UTF-16编码，代表一个字符 "🐪"。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为false。

一旦加上u修饰符号，就会修改下面这些正则表达式的行为:

**(1) 点字符**

点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上u修饰符。

````js
const str = '\uD842\uDFB7' // 表示一个字符

// .除了换行符以外的任意单个字符
console.log(/^.$/.test(str)) // false
console.log(/^.$/u.test(str)) // true
````

上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。

**(2) Unicode字符表示法**

ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。

````js
console.log(/\u{61}/.test('a')) // false

console.log(/\u{61}/u.test('a')) // true
````

上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配61个连续的u。

**(3) 量词**

使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。

```js
console.log(/𠮷{2}/.test('𠮷𠮷')) // false

console.log(/𠮷{2}/u.test('𠮷𠮷')) // true
```

只有在使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。

```js
/^\u{3}$/.test('uuu') // true
```

上面代码中，由于正则表达式没有u修饰符，所以大括号被解读为量词。加上u修饰符，就会被解读为Unicode表达式。

```js
/\u{20BB7}{2}/u.test('𠮷𠮷') // true
```

使用 u 修饰符之后 Unicode 表达式+量词也是可以的。

**(4) 预定义模式**

u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。

```js
/^\S$/.test('𠮷') // false

/^\S$/u.test('𠮷') // true
```

上面代码的\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。

利用这一点，可以写出一个正确返回字符串长度的函数。

```js
function codePointLength(text) {
    const result = text.match(/[\s\S]/gu)
    return result ? result.length : 0
}

const s = '𠮷𠮷'

s.length // 4
codePointLength(s) // 2
```

**(5) i修饰符**

有些Unicode字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。

```js
/[a-z]/i.test('\u212A') // false

/[a-z]/iu.test('\u212A') // true
```

上面代码中，不加u修饰符，就无法识别非规范的K字符。

### Number                数值的扩展

十进制转化为二进制

````js
const a = 5 // 101

console.log(a.toString(2))
````

十进制转化为二进制

````js
const b = 101

console.log(parseInt(b, 2))
````

